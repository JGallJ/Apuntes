Problemas montaje manual:
- Mantenimiento individualizado de fstab en muchas máquinas
- El montaje de SFs a partir de muchas máquinas puede estar muy comprometido si el servidor cae.
- La caída de un servidor importante (ofrece información a muchas máquinas) puede dejar inutilizada esa información para muchos usuarios (/usr/man). Se puede paliar con la utilización de réplicas en otros servidores de reserva (escritura ?)

Solución:
- un demonio que monte los SFs cuando son referenciados (comando cd) y que los desmonta si no se necesitan más

Implementación: automounter (Solaris,Linux,..) o amd (Freebsd,Openbsd, Linux,..., implementación de espacio usuario) :
- Funcionan como servidores NFS
- Pero en lugar de ofrecer el SFs a la red, construyen un nuevo SFs según las especificaciones de sus ficheros de configuración

automounter
- Utiliza tres tipos diferentes de ficheros de configuración ("maps") : mapas directos, indirectos y maestros.
- mapas indirectos:
	- Sirven para montar automáticamente diversos SFs bajo un directorio común. Este directorio está especificado en el mapa maestro. Este ejemplo los situa bajo /puesto29 con el mapa /etc/auto.puesto29
	- ![[Pasted image 20250220161813.png]]
puesto29 es la maquina y luego de los dos puntos el directorio
-ro read only

- mapas directos:
	- No comparten prefijo (directorio común). En /etc/auto.direct 
	- ![[Pasted image 20250220162121.png]]
	- Tiene visibilidad con ls y otros comandos de aceso a directorios a diferencia de los indirectos
- mapas maestros
	- Especifica los mapas (ficheros) directos e indirectos. Y para cada mapa indirecto explicita el directorio común completo
		- automount /etc/auto.master

Replicación 
- No puede realizar automáticamente un desmontaje y remontar en otro servidor, cuando el servidor en curso cae

paquete autofs en linux
- Posibilidad de hacer montajes remotos de SFs de Windows a través de mount.smbfs, y de removibles (disquetes, CDROMs, etc).
- Ejemplos
	- En /etc/init.d/autofs inicialización de /usr/sbin/automount,
	- A partir de fichero de configuración /etc/auto.master que contiene referencias :
	- ![[Pasted image 20250220162725.png]]
	- /etc/auto.misc contiene
	- ![[Pasted image 20250220162827.png]]
	- Y en /etc/auto.home es
	- ![[Pasted image 20250220162925.png]]
	- SI no ponemos el 4 entiende versión 3 por defecto

donde me he metido por dios
![[Pasted image 20250220163344.png]]

se puede usar en entornos controlados donde poder copiar el SF de forma segura
![[Pasted image 20250220163738.png]]
disponible con solo el paquete amd


Maquina Unix sin disco local: todo sobre disco remoto a través de NFS
- Crear un sistema linux base a copiar en el servidor NFS de la siguiente forma :
	- Proveer para el arranque de cada máquina cliente : /sbin , /lib , /bin , /etc , /var , /dev; bajo un directorio por máquina (nº IP)
	- Directorios comunes a las máquinas clientes: /usr (ro), /lib/modules (ro) , /opt (ro), /home (rw)
	- Crear un núcleo de linux con opciones "root over nfs", "IP : bootp support" y "loopback device support". Introducirlo en ROM, disquete de arranque,... Especificar párametros de arranque núcleo (al menos IP y servidorNFS:directorio_máquina_cliente,..)

proceso mas elaborado ya que cada máquina tiene su propia configuración en /etc, por lo que a partir de un punto se tiene que configurar de manera casi individual

CIFS (SMB) y Samba
- Protocolo Common Internet File System (CIFS, antes SMB): compartición de ficheros, impresoras, Autentificación y autorización, resolución de nombres, anuncio de servicios a través de la red.
![[Pasted image 20250220164617.png]]

### Nuevo tema 4, Programación para administración de sistemas heterogéneos
Utilización de lenguajes genéricos multiplataforma (BSDs, Linux, MacOSX, Windows) : perl, python, ruby,..
Normalmente lenguajes interpretados de sintaxis concisa para scripting rápido (realización rápida de programas cortos) como el Shell de Unix :

Aunque ya hay quien utiliza lenguajes concisos compilados (Haskell, Ocaml, ...)

xargs -> ns pero traga como ninguno
lsof -> files openned by processes
tee -> pal fichero y la salida estandar

#### Ruby
Lenguaje interpretado
Altamente dinámico y flexible
- posibilidades de metaprogramación
Orientación objetos pura
Lenguaje rico y con muchas posibilidades
Aplicaciones relevantes
- Puppet, Chef

podemos obviar los objetos, usándolo practicamente como shell




